//大小端模式对union 类型数据的影响

//下面再看一个例子：
//union
//{
//	int i;
//	char a[2];
//}*p, u;
//p = &u;
//p->a[0] = 0x39;
//p->a[1] = 0x38;
//p.i 的值应该为多少呢？

//这里需要考虑存储模式：大端模式和小端模式。

//大端模式（Big_endian）：
//字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。
//小端模式（Little_endian）：
//字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。

//union 型数据所占的空间等于其最大的成员所占的空间。
//对union 型的成员的存取都是相对于该联合体基地址的偏移量为0 处开始
//也就是联合体的访问不论对哪个变量的存取都是从union 的首地址位置开始


//如何用程序确认当前系统的存储模式

//上述问题似乎还比较简单，那来个有技术含量的：请写一个C 函数，
//若处理器是Big_endian 的，则返回0；
//若是Little_endian 的，则返回1。


//先分析一下，按照上面关于大小端模式的定义
//假设int 类型变量i 被初始化为1。

//变量i 占4 个字节，但只有一个字节的值为1，另外三个字节的值都为0。
//如果取出低地址上的值为0，毫无疑问，这是大端模式；
//如果取出低地址上的值为1，毫无疑问，这是小端模式
//既然如此，我们完全可以利用union 类型数据的特点：所有成员的起始地址一致。
//到现在，应该知道怎么写了吧？参考答案如下：

//int checkSystem()
//{
//	union check
//	{
//		int i;
//		char ch;
//	} c;
//	c.i = 1;
//	return (c.ch == 1);
//}

//现在你可以用这个函数来测试你当前系统的存储模式了。
//当然你也可以不用函数而直接去查看内存来确定当前系统的存储模式

//图中0x01 的值存在低地址上，说明当前系统为小端模式。
//不过要说明的一点是，某些系统可能同时支持这两种存储模式
//你可以用硬件跳线或在编译器的选项中设置其存储模式。


//enum 关键字

//很多初学者对枚举(enum)感到迷惑，或者认为没什么用
//其实枚举(enum)是个很有用的数据类型

//枚举类型的使用方法

//一般的定义方式如下：

//enum enum_type_name
//{
//	ENUM_CONST_1,
//	ENUM_CONST_2,
//	...
//	ENUM_CONST_n
//} enum_variable_name;

//注意：enum_type_name 是自定义的一种数据数据类型名
//而enum_variable_name 为enum_type_name类型的一个变量
//也就是我们平时常说的枚举变量。实际上enum_type_name
//类型是对一个变量取值范围的限定，而花括号内是它的取值范围
//即enum_type_name 类型的变量enum_variable_name 只能取值为花括号内的任何一个值
//如果赋给该类型变量的值不在列表中，则会报错或者警告。
//ENUM_CONST_1、ENUM_CONST_2、...、ENUM_CONST_n，这些成员都是常量
//也就是我们平时所说的枚举常量（常量一般用大写）。
//enum 变量类型还可以给其中的常量符号赋值，如果不赋值则会从被赋初值的那个常量开始
//	依次加1，如果都没有赋值，它们的值从0 开始依次递增1。如分别用一个常数表示不同颜
//	色：

//enum Color
//{
//	GREEN = 1,
//	RED,
//	BLUE,
//	GREEN_RED = 10,
//	GREEN_BLUE
//}ColorVal；

//其中各常量名代表的数值分别为：
//GREEN = 1
//RED = 2
//BLUE = 3
//GREEN_RED = 10
//GREEN_BLUE = 11


//枚举与#define 宏的区别

//下面再看看枚举与#define 宏的区别：
//1），#define 宏常量是在预编译阶段进行简单替换。
//枚举常量则是在编译的时候确定其值。
//2），一般在编译器里，可以调试枚举常量
//但是不能调试宏常量。
//3），枚举可以一次定义大量相关的常量
//而#define 宏一次只能定义一个。


//伟大的缝纫师----typedef 关键字
//关于马甲的笑话

//有这样一个笑话：一个猎人在河边抓捕一条蛇，蛇逃进了水里。
//过一会，一个乌龟爬到岸边。猎人一把抓住这个乌龟，大声的说道：
//小样，别你为你穿了个马甲我就不认识你了！
//typedef 关键字是个伟大的缝纫师，擅长做马甲，任何东西穿上这个马甲就立马变样。
//它可以把狼变成一头羊，也能把羊变成一头狼。
//甚至还可以把长着翅膀的鸟人变成天使，同样也能把美丽的天使变成鸟人。
//所以，你千万不要得罪它，一定要掌握它的脾气，不然
//哪天我把你当鸟人，你可别怪我。


//历史的误会----也许应该是typerename

//很多人认为typedef 是定义新的数据类型，这可能与这个关键字有关。
//本来嘛，type 是数据类型的意思；def(ine)是定义的意思
//合起来就是定义数据类型啦。不过很遗憾，这种理解是不正确的。
//也许这个关键字该被替换为“typerename”或是别的词


//typedef 的真正意思是给一个已经存在的数据类型（注意：是类型不是变量）
//取一个别名，而非定义一个新的数据类型。比如：华美绝伦的芍药
//就有个别名-- - “将离”。中国古代男女交往, 往往以芍药相赠, 表达惜别之情
//送芍药就意味着即将分离。所以文人墨客就给芍药取了个
//意味深长的别名---- - “将离”。这个新的名字就表达了那种依依不舍的惜别之情


//这样新的名字与原来的名字相比，就更能表达出想要表达的意思。
//在实际项目中，为了方便，可能很多数据类型（尤其是结构体之类的自定义数据类型）
//需要我们重新取一个适用实际情况的别名。
//这时候typedef 就可以帮助我们。例如


//typedef struct student
//{
//	//code
//}Stu_st, * Stu_pst;//命名规则请参考本章前面部分
//A），struct student stu1；和Stu_st stu1；没有区别。
//B），struct student* stu2；和Stu_pst stu2；和Stu_st* stu2；没有区别。

//这个地方很多初学者迷惑，B）的两个定义为什么相等呢？其实很好理解。我们把
//“struct student{ /*code*/ }”看成一个整体
//typedef 就是给“struct student{/*code*/ }”取了个别名叫“Stu_st”；
//同时给“struct student{ /*code*/ } *”取了个别名叫“Stu_pst”。只不过这两
//个名字同时取而已，好比你给你家小狗取了个别名叫“大黄”
//同时你妹妹给小狗带了小帽子，然后给它取了个别名叫“小可爱”。


//好，下面再把typedef 与const 放在一起看看：
//C), const Stu_pst stu3;
//D), Stu_pst const stu4;
//大多数初学者认为C）里const 修饰的是stu3 指向的对象；D）里const 修饰的是stu4
//这个指针。很遗憾，C）里const 修饰的并不是stu3 指向的对象。
//那const 这时候到底修饰的是什么呢？我们在讲解const int i 的时候说过const 放在类型名“int”前后都行；
//而const int* p 与int* const p 则完全不一样。也就是说
//我们看const 修饰谁都时候完全可以将数据类型名视而不见，当它不存在。
//反过来再看“const Stu_pst stu3”，Stu_pst 是“struct student
//{ /*code*/ } *”的别名, “struct student{/*code*/ } *”是一个整体。
//对于编译器来说，只认为Stu_pst 是一个类型名所以在解析的时候很自然的把“Stu_pst”这个数据类型名忽略掉。
//现在知道const 到底修饰的是什么了吧？


//typedef 与#define 的区别

//噢，上帝！这真要命！别急，要命的还在后面呢。看如下例子：
//E）， #define INT32 int
//unsigned INT32 i = 10；
//F），typedef int int32；
//unsigned int32 j = 10；
//其中F)编译出错，为什么呢？E）不会出错，这很好理解
//因为在预编译的时候INT32被替换为int，而unsigned int i = 10；
//语句是正确的。但是，很可惜，用typedef 取的别名不支持这种类型扩展。
//另外，想想typedef static int int32 行不行？为什么？

//下面再看一个与#define 宏有关的例子：
//G)，#define PCHAR char*
//PCHAR p3, p4;
//H），typedef char* pchar;
//pchar p1, p2;
//两组代码编译都没有问题，但是，这里的p4 却不是指针
//仅仅是一个char 类型的字符。这种错误很容易被忽略，所以用#define 的时候要慎之又慎。
//关于#define 当然还有很多话题需要讨论，请看预处理那一章。
//当然关于typedef 的讨论也还没有结束，在指针与数组那一章，我们还要继续讨论。


//#define a int[10]与typedef int a[10]；

//留两个问题：
//1），#define a int[10]
//A), a[10] a[10];
//B), a[10] a;
//C), int a[10];
//D), int a;
//E), a b[10];
//F), a b;
//G), a* b[10];
//H), a* b;
//2), typedef int a[10];
//A), a[10] a[10];
//B), a[10] a;
//C), int a[10];
//D), int a;
//E), a b[10];
//F), a b;
//G), a* b[10];
//H), a* b;
//3），#define a int* [10]
//A), a[10] a[10];
//B), a[10] a;
//C), int a[10];
//D), int a;
//E), a b[10];
//F), a b;
//G), a* b[10];
//H), a* b;
//4), typedef int* a[10];
//A), a[10] a[10];
//B), a[10] a;
//C), int a[10];
//D), int a;
//E), a b[10];
//F), a b;
//G), a* b[10];
//H), a* b;
//5），#define * a int[10]
//A), a[10] a[10];
//B), a[10] a;
//C), int a[10];
//D), int a;
//E), a b[10];
//F), a b;
//G), a* b[10];
//H), a* b;
//6), typedef int(*a)[10];
//A), a[10] a[10];
//B), a[10] a;
//C), int a[10];
//D), int a;
//E), a b[10];
//F), a b;
//G), a* b[10];
//H), a* b;
//7），#define * a * int[10]
//A), a[10] a[10];
//B), a[10] a;
//C), int a[10];
//D), int a;
//E), a b[10];
//F), a b;
//G), a* b[10];
//H), a* b;
//8), typedef int* (*a)[10];
//A), a[10] a[10];
//B), a[10] a;
//C), int a[10];
//D), int a;
//E), a b[10];
//F), a b;
//G), a* b[10];
//H), a* b;
//请判断这里面哪些定义正确，哪些定义不正确。另外，int[10]和a[10]到底该怎么用？



//第二章符号


//符号有什么好说的呢？确实，符号可说的内容要少些，但总还是有些可以唠叨地方。
//有一次上课，我问学生：‘ / ’这个符号在C 语言里都用在哪些地方？
//没有一个人能答完整。这说明C 语言的基础掌握不牢靠
//如果真正掌握了C 语言，你就能很轻易的回答上来。这个问题就请读者试着回答一下吧。
//本章不会像关键字一样一个一个深入讨论，只是将容易出错的地方讨论一下。


//符号名称     符号名称
//， 逗号      > 右尖括号
//.圆点       !感叹号
//； 分号     | 竖线
//： 冒号     / 斜杠
//？ 问号     \ 反斜杠
//’ 单引号   ~波折号
//“ 双引号    # 井号
//(左圆括号    ) 右圆括号
//[左方括号    ] 右方括号
//{ 左大括号   } 右大括号
//% 百分号     & and（与）
//^ xor（异或） * 乘号
//- 减号       = 等于号
//< 左尖括号    + 加号


//C 语言的基本符号就有20 多个，每个符号可能同时具有多重含义，而且这些符号之间
//相互组合又使得C 语言中的符号变得更加复杂起来。
//你也许听说过“国际C 语言乱码大赛（IOCCC）”，能获奖的人毫无疑问是世界顶级C
//程序员。这是他们利用C 语言的特点极限挖掘的结果。下面这个例子就是网上广为流传的
//一个经典作品：
//#i nclude <stdio.h>
//main(t, _, a)char* a; {return!0 < t ? t < 3 ? main(-79, -13, a + main(-87, 1 - _,
//	main(-86, 0, a + 1) + a)) : 1, t < _ ? main(t + 1, _, a) : 3, main(-94, -27 + t, a) && t == 2 ? _ < 13 ?
//	main(2, _ + 1, "%s %d %d\n") : 9 : 16 : t < 0 ? t < -72 ? main(_, t,
//		"@n'+,#'/*{}w+/w#cdnr/+,{}r/*de}+,/*{*+,/w{%+,/w#q#n+,/#{l+,/n{n+,/+#n+,/#\
//;#q#n+,/+k#;*+,/'r :'d*'3,}{w+K w'K:'+}e#';dq#'l \
q#'+d'K#!/+k#;q#'r}eKK#}w'r}eKK{nl]'/#;#q#n'){)#}w'){){nl]'/+#n';d}rw' i;# \
){nl]!/n{n#'; r{#w'r nc{nl]'/#{l,+'K {rw' iK{;[{nl]'/w#q#n'wk nw' \
iwk{KK{nl]!/w{%'l##w#' i; :{nl]'/*{q#'ld;r'}{nlwb!/*de}'c \
;;{nl'-{}rw]'/+,}##'*}#nc,',#nw]'/+kd'+e}+;#'rdq#w! nr'/ ') }+}{rl#'{n' ')# \
}'+}##(!!/")
//:t < -50 ? _ == *a ? putchar(31[a]) : main(-65, _, a + 1) : main((*a == '/') + t, _, a + 1)
//	: 0 < t ? main(2, 2, "%s") : *a == '/' || main(0, main(-61, *a,
//		"!ek;dc i@bK'(q)-[w]*%n+r3#l,{}:\nuwloca-O;m.vpbks,fxntdCeghiry"), a + 1); }
//		还没发狂？看来你抵抗力够强的。这是IOCCC 1988 年获奖作品，作者是Ian Phillipps。
//			毫无疑问，Ian Phillipps 是世界上最顶级的C 语言程序员之一。你可以数数这里面用了多少
//			个符号。当然这里我并不会讨论这段代码，也并不是鼓励你也去写这样的代码（关于这段代
//			码的分析，你可以上网查询）。恰恰相反，我要告诉你的是：
//			大师把代码写成这样是经典，你把代码写成这样是垃圾！
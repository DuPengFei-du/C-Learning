#define _CRT_SECURE_NO_WARNINGS 1



//const 关键字也许该被替换为readolny

//const 是constant 的缩写，是恒定不变的意思，也翻译为常量、常数等。
//很不幸，正是因为这一点，很多人都认为被const 修饰的值是常量。
//这是不精确的，精确的说应该是只读的变量，其值在编译时不能被使用
//因为编译器在编译时不知道其存储的内容。或许当初这个关键字应该被替换为readonly。
//那么这个关键字有什么用处和意义呢？const 推出的初始目的，正是为了取代预编译指令
//消除它的缺点，同时继承它的优点。我们看看它与define 宏的区别。
//很多人误以为define 是关键字，在这里我提醒你再回到本章前面看看32 个关键字里是否有define
//注意:define不是关键字


//const 修饰的只读变量

//定义const 只读变量，具有不可变性。
//例如：
//const intMax = 100;
//intArray[Max];
//这里请在Visual C++6.0 里分别创建.c 文件和.cpp 文件测试一下。
//你会发现在.c 文件中，编译器会提示出错，而在.cpp 文件中则顺利运行。
//为什么呢？我们知道定义一个数组必须指定其元素的个数。这也从侧面证实在C 语言中
//const 修饰的Max 仍然是变量，只不过是只
//读属性罢了；而在C++里，扩展了const 的含义，这里就不讨论了。
//注意：const 修饰的只读变量必须在定义的同时初始化，想想为什么？
//留一个问题：case 语句后面是否可以是const 修饰的只读变量呢？请动手测试一下。


//节省空间，避免不必要的内存分配，同时提高效率

//编译器通常不为普通const 只读变量分配存储空间，而是将它们保存在符号表中，这使
//得它成为一个编译期间的值，没有了存储与读内存的操作，使得它的效率也很高。
//例如：
//#define M 3 //宏常量
//const int N = 5; //此时并未将N 放入内存中
//......
//int i = N; //此时为N 分配内存，以后不再分配！
//int I = M; //预编译期间进行宏替换，分配内存
//int j = N; //没有内存分配
//int J = M; //再进行宏替换，又一次分配内存！


//const 定义的只读变量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define
//一样给出的是立即数，所以，const 定义的只读变量在程序运行过程中只有一份拷贝（因为
//它是全局的只读变量，存放在静态区），而#define 定义的宏常量在内存中有若干个拷贝。
//#define 宏是在预编译阶段进行替换，而const 修饰的只读变量是在编译的时候确定其值。
//#define 宏没有类型，而const 修饰的只读变量具有特定的类型。


//修饰一般变量

//一般常量是指简单类型的只读变量。这种只读变量在定义时，修饰符const 可以用在类
//型说明符前，也可以用在类型说明符后。例如：
//int const i = 2; 或const int i = 2;

//修饰数组

//定义或说明一个只读数组可采用如下格式：
//int const a[5] = { 1, 2, 3, 4, 5 }; 或
//const int a[5] = { 1, 2, 3, 4, 5 };


//修饰指针

//const int* p; // p 可变，p 指向的对象不可变
//int const* p; // p 可变，p 指向的对象不可变
//int* const p; // p 不可变，p 指向的对象可变
//const int* const p; //指针p 和p 指向的对象都不可变
//在平时的授课中发现学生很难记住这几种情况。这里给出一个记忆和理解的方法：
//先忽略类型名（编译器解析的时候也是忽略类型名），我们看const 离哪个近。“近水楼
//台先得月”，离谁近就修饰谁。
//const int* p; //const 修饰*p,p 是指针，*p 是指针指向的对象，不可变
//int const* p; //const修饰*p,p 是指针，*p 是指针指向的对象，不可变
//int* const p; //const修饰p，p 不可变，p 指向的对象可变
//const int* const p; //前一个const 修饰*p,后一个const 修饰p，指针p 和p 指向的对象
//都不可变


//修饰函数的参数

//const 修饰符也可以修饰函数的参数，当不希望这个参数值被函数体内意外改变时使
//用。例如：
//void Fun(const int i);
//告诉编译器i 在函数体中的不能改变，从而防止了使用者的一些无意的或错误的修改。

//修饰函数的返回值

//const 修饰符也可以修饰函数的返回值，返回值不可被改变。例如：
//const int Fun(void);
//在另一连接文件中引用const 只读变量：
//extern const int i; //正确的声明
//extern const int j = 10; //错误！只读变量的值不能改变。
//注意这里是声明不是定义，关于声明和定义的区别，请看本章开始处。
//讲了这么多讲完了吗？远没有。在C++里，对const 做了进一步的扩展，还有很多知识未能讲完。
//有兴趣的话，不妨查找相关资料研究研究。


//最易变的关键字----volatile
//volatile 是易变的、不稳定的意思。很多人根本就没见过这个关键字
//不知道它的存在。也有很多程序员知道它的存在，但从来没用过它。
//我对它有种“杨家有女初长成, 养在深闺人未识” 的感觉。
//volatile 关键字和const 一样是一种类型修饰符
//用它修饰的变量表示可以被某些编译器
//未知的因素更改，比如操作系统、硬件或者其它线程等。
//遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化
//从而可以提供对特殊地址的稳定访问。
//先看看下面的例子：

//int i = 10;
//int j = i；//(1)语句
//int k = i；//(2)语句
//
//这时候编译器对代码进行优化，因为在（1）、（2）两条语句中
//i 没有被用作左值。这时候编译器认为i 的值没有发生改变
//所以在（1）语句时从内存中取出i 的值赋给j 之后，这个
//值并没有被丢掉，而是在（2）语句时继续用这个值给k 赋值。
//编译器不会生成出汇编代码重新从内存里取i 的值，这样提高了效率。
//但要注意：（1）、（2）语句之间i 没有被用作左值才行

//再看另一个例子：

//volatile int i = 10;
//int j = i；//(3)语句
//int k = i；//(4)语句
//volatile 关键字告诉编译器i 是随时可能发生变化的
//每次使用它的时候必须从内存中取出i
//的值，因而编译器生成的汇编代码会重新从i 的地址处读取数据放在k 中。
//这样看来，如果i 是一个寄存器变量或者表示一个端口数据或者是多个线程的共享数
//据，就容易出错
//所以说volatile 可以保证对特殊地址的稳定访问。但是注意：在VC++6.0 中
//一般Debug 模式没有进行代码优化，所以这个关键字的作
//用有可能看不出来。你可以同时生成Debug 版和Release 版的程序做个测试。
//留一个问题：const volatile int i = 10；
//这行代码有没有问题？如果没有，那i 到底是什么属性？


//最会带帽子的关键字----extern

//extern，外面的、外来的意思。那它有什么作用呢？举个例子
//假设你在大街上看到一个黑皮肤绿眼睛红头发的美女（外星人？）或者帅哥。
//你的第一反应就是这人不是国产的。
//extern 就相当于他们的这些区别于中国人的特性。extern 可以置于变量或者函数前，以
//标示变量或者函数的定义在别的文件中
//下面的代码用到的这些变量或函数是外来的，不是本文件定义的
//提示编译器遇到此变量和函数时在其他模块中寻找其定义。
//就好比在本文件中给这些外来的变量或函数带了顶帽子
//告诉本文件中所有代码，这些家伙不是土著。
//那你想想extern 修饰的变量或函数是定义还是声明？

//看列子：
//A.c 文件中定义： B.c 文件中用extern 修饰：
//int i = 10； extern int i；//写成i = 10；行吗？
//void fun（void） extern void fun（void）；//两个void 可否省略？
//{
//	//code
//}
//C.h 文件中定义： D.c 文件中用extern 修饰：
//int j = 1; extern double j；//这样行吗？为什么？
//int k = 2; j = 3.0；//这样行吗？为什么？

//至于extern“C”的用法，一般认为属于C++的范畴，这里就先不讨论。当然关于extern
//的讨论还远没有结束，在指针与数组那一章，你还会和它亲密接触的。


//struct 关键字

//struct 是个神奇的关键字，它将一些相关联的数据打包成一个整体，方便使用。
//在网络协议、通信控制、嵌入式系统、驱动开发等地方
//我们经常要传送的不是简单的字节流（char 型数组），而是多种数据组合起来的一个整体，
//其表现形式是一个结构体。
//经验不足的开发人员往往将所有需要传送的内容依顺序保存在char 型数组中，
//通过指针偏移的方法传送网络报文等信息。这样做编程复杂，易出错，
//而且一旦控制方式及通信协议有所变化，程序就要进行非常细致的修改，
//非常容易出错。这个时候只需要一个结构体就能搞定。
//平时我们要求函数的参数尽量不多于4 个
//如果函数的参数多于4 个使用起来非常容易出错（包括每个参数的意义和顺序都容易弄错）
//效率也会降低（与具体CPU 有关，ARM芯片对于超过4 个参数的处理就有讲究，具体请参考相关资料）。
//这个时候，可以用结构体压缩参数个数。

//空结构体多大？

//结构体所占的内存大小是其成员所占内存之和（关于结构体的内存对齐，请参考预处
//理那章）。这点很容易理解，但是下面的这种情况呢？

//struct student
//{
//}stu;

//sizeof(stu)的值是多少呢？在Visual C++ 6.0 上测试一下。

//很遗憾，不是0，而是1。为什么呢？你想想
//如果我们把struct student 看成一个模子的话
//你能造出一个没有任何容积的模子吗？显然不行。
//编译器也是如此认为。编译器认为任何一种数据类型都有其大小
//用它来定义一个变量能够分配确定大小的空间。既然如此
//编译器就理所当然的认为任何一个结构体都是有大小的
//哪怕这个结构体为空。那万一结构体真的为空，它的大小为什么值比较合适呢？
//假设结构体内只有一个char 型的数据成员，那其大小为1byte（这里先不考虑内存对齐的情况
//也就是说非空结构体类型数据最少需要占一个字节的空间
//而空结构体类型数据总不能比最小的非空结构体类型数据所占的空间大吧。
//这就麻烦了，空结构体的大小既不能为0，也不能大于1
//怎么办？定义为0.5个byte？但是内存地址的最小单位是1 个byte，0.5 个byte 怎么处理？
//解决这个问题的最好办法就是折中
//编译器理所当然的认为你构造一个结构体数据类型是用来打包一些数据成员的
//而最小的数据成员需要1 个byte，编译器为每个结构体类型数据至少预留1 个byte的空间。
//所以，空结构体的大小就定位1 个byte。


//柔性数组

//也许你从来没有听说过柔性数组（flexible array）这个概念
//但是它确实是存在的。C99 中，结构中的最后一个元素允许是未知大小的数组
//这就叫做柔性数组成员，
//但结构中的柔性数组成员前面必须至少一个其他成员。
//柔性数组成员允许结构中包含一个大小可变的数组。
//sizeof 返回的这种结构大小不包括柔性数组的内存。
//包含柔性数组成员的结构用malloc()函数进行内存的动态分配
//并且分配的内存应该大于结构的大小，以适应柔性数组
//的预期大小。

//柔性数组到底如何使用呢？看下面例子：
//typedef struct st_type
//{
//	int i;
//	int a[0];
//}type_a;

//有些编译器会报错无法编译可以改成：
//typedef struct st_type
//{
//	int i;
//	int a[];
//}type_a;

//这样我们就可以定义一个可变长的结构体， 用sizeof(type_a) 得到的只有4 ， 就是
//sizeof(i) = sizeof(int)。那个0 个元素的数组没有占用空间，而后我们可以进行变长操作了。通
//过如下表达式给结构体分配内存：

//type_a* p = (type_a*)malloc(sizeof(type_a) + 100 * sizeof(int));

//这样我们为结构体指针p 分配了一块内存。用p->item[n]就能简单地访问可变长元素。
//但是这时候我们再用sizeof（* p）测试结构体的大小
//发现仍然为4。是不是很诡异？我们不是给这个数组分配了空间么？
//别急，先回忆一下我们前面讲过的“模子”
//在定义这个结构体的时候，模子的大小就
//已经确定不包含柔性数组的内存大小。柔性数组只是编外人员
//不占结构体的编制。只是说在使用柔性数组时需要把它当作结构体的一个成员
//仅此而已。再说白点，柔性数组其实与结构体没什么关系
//只是“挂羊头卖狗肉”而已，算不得结构体的正式成员。
//需要说明的是：C89 不支持这种东西，C99 把它作为一种特例加入了标准。
//但是，C99所支持的是incomplete type，而不是zero array
//形同int item[0]; 这种形式是非法的，C99 支
//持的形式是形同int item[]; 只不过有些编译器把int item[0];
//作为非标准扩展来支持，而且在C99 发布之前已经有了这种非标准扩展了
//C99 发布之后，有些编译器把两者合而为一了
//当然，上面既然用malloc 函数分配了内存
//肯定就需要用free 函数来释放内存：free(p);
//经过上面的讲解，相信你已经掌握了这个看起来似乎很神秘的东西。不过实在要是没
//掌握也无所谓，这个东西实在很少用。


//struct 与class 的区别

//在C++里struct 关键字与class 关键字一般可以通用
//只有一个很小的区别。struct 的成员默认情况下属性是public 的
//而class 成员却是private 的。很多人觉得不好记，其实很容易
//你平时用结构体时用public 修饰它的成员了吗？
//既然struct 关键字与class 关键字可以通用，你也不要认为结构体内不能放函数了。
//当然，关于结构体的讨论远没有结束，在指针与数组那一章，你还会要和它打交道的。


//union 关键字

//union 关键字的用法与struct 的用法非常类似。
//union 维护足够的空间来置放多个数据成员中的“一种”，而不是为每一个数据成员配置
//空间，在union 中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，所
//有的数据成员具有相同的起始地址。例子如下：

////	union StateMachine
////{
////	char character;
////	int number;
////	char* str;
////	double exp;
////};

//一个union 只配置一个足够大的空间以来容纳最大长度的数据成员，以上例而言，最大
//长度是double 型态，所以StateMachine 的空间大小就是double 数据类型的大小。
//在C++里，union 的成员默认属性页为public。union 主要用来压缩空间。
//如果一些数据不可能在同一时间同时被用到，则可以使用union。
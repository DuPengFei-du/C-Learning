#define _CRT_SECURE_NO_WARNINGS 1



//goto 关键字

//一般来说，编码的水平与goto 语句使用的次数成反比。
//有的人主张慎用但不禁用goto语句，但我主张禁用

//禁用goto 语句。
//自从提倡结构化设计以来，goto 就成了有争议的语句。首先
//由于goto 语句可以灵活跳转，如果不加限制，它的确会破坏结构化设计风格
//其次，goto 语句经常带来错误或隐患。
//它可能跳过了变量的初始化、重要的计算等语句，例如：


//struct student* p = NULL;
//…
//goto state;
//p = (struct student*)malloc(…); //被goto 跳过,没有初始化
//{
//	⋯
//}
//{
//	⋯
//}
//for (n = 0; n < 10; n++)
//{
//	…
//		n = 8;//不可，很可能违背了你的原意
//	…
//}
//⋯
//state :
////使用p 指向的内存里的值的代码
//⋯

//如果编译器不能发觉此类错误，每用一次goto 语句都可能留下隐患。


//void 关键字
//void 有什么好讲的呢？如果你认为没有，那就没有；但如果你认为有
//那就真的有。有点像“色即是空，空即是色

//void a？

//void 的字面意思是“空类型”，void* 则为“空类型指针”
//void* 可以指向任何类型的数据。
//void 几乎只有“注释”和限制程序的作用，因为从来没有人会定义一个void 变量、
//看看下面的例子：
//void a;
//Visual C++6.0 上，这行语句编译时会出错，提示“illegal use of type 'void'”。
//不过，即使void a 的编译不会出错，它也没有任何实际意义。


//void 真正发挥的作用在于：
//（1） 对函数返回的限定
//（2） 对函数参数的限定。

//众所周知，如果指针p1 和p2 的类型相同，那么我们可以直接在p1 和p2 间互相赋值；
//如果p1 和p2 指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的
//指针类型转换为左边指针的类型。

//例如：
//float* p1;
//int* p2;
//p1 = p2;
//其中p1 = p2 语句会编译出错，提示“'=' : cannot convert from 'int *' to 'float *'”，必须改为：
//p1 = (float*)p2;

//而void* 则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换：
//void* p1;
//int* p2;
//p1 = p2;

//但这并不意味着，void* 也可以无需强制类型转换地赋给其它类型的指针。因为“空类型”可
//以包容“有类型”，而“有类型”则不能包容“空类型”。比如，我们可以说“男人和女人都是人”，
//但不能说“人是男人”或者“人是女人”。下面的语句编译出错：
//
//void* p1;
//int* p2;
//p2 = p1;
//提示“'=' : cannot convert from 'void *' to 'int *'”。


//void 修饰函数返回值和参数
//如果函数没有返回值，那么应声明为void 类型
//在C 语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理。
//但是许多程序员却误以为其为void 类型 如：

//add(int a, int b)
//{
//	return a + b;
//}
//intmain(int argc, char* argv[]) //甚至很多人以为main 函数无返回值
////或是为void 型的
//{
//	printf("2 + 3 = %d", add(2, 3));
//}
//程序运行的结果为输出： 2 + 3 = 5
//这说明不加返回值说明的函数的确为int 函数。

//因此，为了避免混乱，我们在编写C 程序时，对于任何函数都必须一个不漏地指定其
//类型。如果函数没有返回值，一定要声明为void 类型。这既是程序良好可读性的需要，也
//是编程规范性的要求。另外，加上void 类型声明后，也可以发挥代码的“自注释”作用。所
//谓的代码的“自注释”即代码能自己注释自己。


//如果函数无参数, 那么应声明其参数为void
//在C++语言中声明一个这样的函数：
//int function(void)
//{
//	return 1;
//}
//则进行下面的调用是不合法的：function(2);
//因为在C++中，函数参数为void 的意思是这个函数不接受任何参数。


//#include "stdio.h"
//fun()
//{
//	return 1;
//}
//main()
//{
//	printf("%d", fun(2));
//	getchar();
//}

//编译正确且输出1，这说明，在C 语言中，可以给无参数的函数传送任意类型的参数，
//但是在C++编译器中编译同样的代码则会出错。在C++中，不能向无参数的函数传送任何
//参数，出错提示“'fun' : function does not take 1 parameters”。
//所以，无论在C 还是C++中，若函数不接受任何参数，一定要指明参数为void。


//千万小心又小心使用void 指针类型。
//按照ANSI(American National Standards Institute)标准，不能对void 指针进行算法操作，
//即下列操作都是不合法的：
//void* pvoid;
//pvoid++; //ANSI：错误
//pvoid += 1; //ANSI：错误
//ANSI 标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指
//向数据类型大小的。也就是说必须知道内存目的地址的确切值。


//例如：
//int* pint;
//pint++; //ANSI：正确
//但是大名鼎鼎的GNU(GNU's Not Unix 的递归缩写)则不这么认定，它指定void *的算法
//	操作与char* 一致。因此下列语句在GNU 编译器中皆正确：
//	pvoid++; //GNU：正确
//pvoid += 1; //GNU：正确
//在实际的程序设计中，为符合ANSI 标准，并提高程序的可移植性，我们可以这样编写
//实现同样功能的代码：


//void* pvoid;
//(char*)pvoid++; //ANSI：正确；GNU：正确
//(char*)pvoid += 1; //ANSI：错误；GNU：正确
//GNU 和ANSI 还有一些区别，总体而言，GNU 较ANSI 更“开放”，提供了对更多语法
//的支持。但是我们在真实设计时，还是应该尽可能地符合ANSI 标准


//如果函数的参数可以是任意类型指针，那么应声明其参数为void* 。
//典型的如内存操作函数memcpy 和memset 的函数原型分别为：
//void* memcpy(void* dest, const void* src, size_t len);
//void* memset(void* buffer, int c, size_t num);
//这样，任何类型的指针都可以传入memcpy 和memset 中，这也真实地体现了内存操作
//函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。如果memcpy
//和memset 的参数类型不是void* ，而是char* ，那才叫真的奇怪了！这样的memcpy 和memset
//明显不是一个“纯粹的，脱离低级趣味的”函数！


//void 不能代表一个真实的变量

//void 不能代表一个真实的变量。
//因为定义变量时必须分配内存空间，定义void 类型变量，编译器到底分配多大的内存呢。
//下面代码都企图让void 代表一个真实的变量，因此都是错误的代码：
//void a; //错误
//function(void a); //错误
//void 体现了一种抽象，这个世界上的变量都是“有类型”的，譬如一个人不是男人就是女
//人（人妖不算）。
//void 的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中“抽象基类”的概
//念，也很容易理解void 数据类型。正如不能给抽象基类定义一个实例，我们也不能定义一
//个void（让我们类比的称void 为“抽象数据类型”）变量。
//void 简单吧？到底是“色”还是“空”呢？


//return 关键字
//return 用来终止一个函数并返回其后面跟着的值。
//return （Val）；//此括号可以省略。但一般不省略，尤其在返回一个表达式的值时。
//return 可以返回些什么东西呢？看下面例子：
//char* Func(void)
//{
//	char str[30];
//	…
//		return str;
//}
//str 属于局部变量，位于栈内存中，在Func 结束的时候被释放，所以返回str 将导致错误。


//const 关键字也许该被替换为readolny
//const 是constant 的缩写，是恒定不变的意思，也翻译为常量、常数等。
//很不幸，正是因为这一点，很多人都认为被const 修饰的值是常量。
//这是不精确的，精确的说应该是只读的变量，其值在编译时不能被使用
//因为编译器在编译时不知道其存储的内容。
//或许当初这个关键字应该被替换为readonly。那么这个关键字有什么用处和意义呢？

//const 推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点。
//我们看看它与define 宏的区别。（很多人误以为define 是关键字，在这里我提醒你再回到本
//章前面看看32 个关键字里是否有define）


//const 修饰的只读变量
//定义const 只读变量，具有不可变性。
//例如：
//const intMax = 100;
//intArray[Max];


//这里请在Visual C++6.0 里分别创建.c 文件和.cpp 文件测试一下。
//你会发现在.c 文件中，编译器会提示出错，而在.cpp 文件中则顺利运行。
//为什么呢？我们知道定义一个数组必须指定其元素的个数。这也从侧面证实在C 语言中
//const 修饰的Max 仍然是变量，只不过是只读属性罢了；
//而在C++里，扩展了const 的含义，这里就不讨论了。

//注意：const 修饰的只读变量必须在定义的同时初始化，想想为什么？
//留一个问题：case 语句后面是否可以是const 修饰的只读变量呢？请动手测试一下。


//节省空间，避免不必要的内存分配，同时提高效率
//编译器通常不为普通const 只读变量分配存储空间
//而是将它们保存在符号表中，这使得它成为一个编译期间的值
//没有了存储与读内存的操作，使得它的效率也很高。

//#define M 3 //宏常量
//const int N = 5; //此时并未将N 放入内存中
//......
//int i = N; //此时为N 分配内存，以后不再分配！
//int I = M; //预编译期间进行宏替换，分配内存
//int j = N; //没有内存分配
//int J = M; //再进行宏替换，又一次分配内存！


//const 定义的只读变量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define
//一样给出的是立即数，所以，const 定义的只读变量在程序运行过程中只有一份拷贝（因为
//它是全局的只读变量，存放在静态区），而#define 定义的宏常量在内存中有若干个拷贝。
//#define 宏是在预编译阶段进行替换，而const 修饰的只读变量是在编译的时候确定其值。
//#define 宏没有类型，而const 修饰的只读变量具有特定的类型。